[{"title":"leetcode 76 最小覆盖字串","url":"/2024/08/22/post/","content":"\n# 描述\n\n> 给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 \"\" 。\n\n# 注意\n\n> *对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。\n> *如果 s 中存在这样的子串，我们保证它是唯一的答案。\n\n# 示例 1\n\n> **输入:** s = \"ADOBECODEBANC\", t = \"ABC\"\n> **输出:** \"BANC\"\n> **解释:** 最小覆盖子串 \"BANC\" 包含来自字符串 t 的 'A'、'B' 和 'C'。\n\n# 示例 2\n\n> **输入:** s = \"a\", t = \"a\"\n> **输出:** \"a\"\n> **解释:** t 中两个字符 'a' 均应包含在 s 的子串中，因此没有符合条件的子字符串，返回空字符串。\n\n# 测试用例\n\n> s='ADOBECODEBANC', t='ABC'\n\n# 思路\n\n> 1.对于这种在两个数组中进行比较的题目，首先想到的是采用哈希表；题目又要求在第一个子串中重复寻找，因此可以使用双指针法（也可以称为滑动窗口）。首先使用一个哈希表 t_map 来保存字符串 t 中的元素\n\n<style>  \n  table {   \n    width: auto;\n    max-width: 30em;\n    margin: auto;\n  }\n  th, td {  \n    text-align: center; /* 使表格内容居中 */  \n  }\n</style>\n<table>\n    <tr>\n        <th rowspan=1 colspan=2> t </th>\n    </tr>\n    <tr>\n        <td> char </td>\n        <td> count </td>\n    </tr>\n    <tr>\n        <td> A </td>\n        <td> 1 </td>\n    </tr>\n    <tr>\n        <td> B </td>\n        <td> 1 </td>\n    </tr>\n    <tr>\n        <td> C </td>\n        <td> 1 </td>\n    </tr>\n</table>\n\n> 2.可以看到字符串 t 总共包含了字符 A，B，C，且它们出现的次数分别为 1，用 cnt 表示字符 A，B，C 出现的总和，其值为 3. 同样的，使用哈希表 s_map 来表示字符串 s 中，字符 A，B，C 出现的频率。\n\n<table>\n    <tr>\n        <th rowspan=1 colspan=2> s </th>\n    </tr>\n    <tr>\n        <td> char </td>\n        <td> count </td>\n    </tr>\n    <tr>\n        <td> A </td>\n        <td> 0 </td>\n    </tr>\n    <tr>\n        <td> B </td>\n        <td> 0 </td>\n    </tr>\n    <tr>\n        <td> C </td>\n        <td> 0 </td>\n    </tr>\n</table>\n\n> 3.初始化字符串 s 的快、慢指针为 0，字串长度 length 为 INT32_MAX；定义一个变量 flag，表示字符 A，B，C 出现的总和（注意：flag 值的变化需与哈希表 t_map 中的值相比较）。然后快指针一步步往后遍历，当快指针指向的元素存在于字符串 t 中的字符时，哈希表 s_map 中相应的元素频率加 1，同时判断哈希表 t_map 和哈希表 s_map 其元素是否相等，如果相等，则 flag 加 1.\n> ![图片](/images/1.png)\n\n<table>\n    <tr>\n        <th rowspan=1 colspan=2> s </th>\n    </tr>\n    <tr>\n        <td> char </td>\n        <td> count </td>\n    </tr>\n    <tr>\n        <td> A </td>\n        <td> 1 </td>\n    </tr>\n    <tr>\n        <td> B </td>\n        <td> 0 </td>\n    </tr>\n    <tr>\n        <td> C </td>\n        <td> 0 </td>\n    </tr>\n</table>\n\n> 4.此时，哈希表 s_map 与 t_map 中字符 A 出现的频率一致，flag 加 1.\n\n> ![图片](/images/2.png)\n\n<table>\n    <tr>\n        <th rowspan=1 colspan=2> s </th>\n    </tr>\n    <tr>\n        <td> char </td>\n        <td> count </td>\n    </tr>\n    <tr>\n        <td> A </td>\n        <td> 1 </td>\n    </tr>\n    <tr>\n        <td> B </td>\n        <td> 1 </td>\n    </tr>\n    <tr>\n        <td> C </td>\n        <td> 1 </td>\n    </tr>\n</table>\n\n> 5.当 flag 等于 cnt 时，记录此时字串的长度，其值为 fast - slow + 1，并使其与上一次的字串长度 length 比较，取较小值为 length；然后停止移动快指针，移动慢指针， 同时记录哈希表 s_map 中字符频率的变化：当慢指针指定的元素包含于字符串 t 中的元素时，哈希表元素频率减 1；如果哈希表 t_map 对应的元素频率大于哈希表 s_map 的元素频率时，flag 减 1.\n\n> ![图片](/images/3.png)\n\n<table>\n    <tr>\n        <th rowspan=1 colspan=2> s </th>\n    </tr>\n    <tr>\n        <td> char </td>\n        <td> count </td>\n    </tr>\n    <tr>\n        <td> A </td>\n        <td> 0 </td>\n    </tr>\n    <tr>\n        <td> B </td>\n        <td> 1 </td>\n    </tr>\n    <tr>\n        <td> C </td>\n        <td> 1 </td>\n    </tr>\n</table>\n\n> 6.移动慢指针后，再重新比较 flag 值是否与 cnt 值相等，如果相等，继续移动慢指针；否则回到原循环，移动快指针。\n\n> ![图片](/images/4.png)\n\n<table>\n    <tr>\n        <th rowspan=1 colspan=2> s </th>\n    </tr>\n    <tr>\n        <td> char </td>\n        <td> count </td>\n    </tr>\n    <tr>\n        <td> A </td>\n        <td> 1 </td>\n    </tr>\n    <tr>\n        <td> B </td>\n        <td> 2 </td>\n    </tr>\n    <tr>\n        <td> C </td>\n        <td> 1 </td>\n    </tr>\n</table>\n\n> 7.继续循环第 5 步，直到快慢指针均遍历完整个数组。\n\n# CPP 代码\n\n```C++\nclass Solution {\npublic:\n    string minWindow(string s, string t) {\n        if(s.length() == 0 || t.length() == 0)return \"\";\n        unordered_map<char, int> ct, cs;\n        for(auto c:t) ct[c]++;\n        int left=0, right=0, length=INT32_MAX, flag = 0, tCount = ct.size(), strStart;\n        while(right < s.length()){\n            if(ct.count(s[right])){\n                cs[s[right]]++;\n                if(cs[s[right]] == ct[s[right]]){\n                    flag++;\n                }\n            }\n            while(flag == tCount){\n                if(right - left + 1 < length){\n                    length = right - left + 1;\n                    strStart = left;\n                }\n                if(ct.count(s[left])){\n                    cs[s[left]]--;\n                    if(ct[s[left]] > cs[s[left]]){\n                        flag--;\n                    }\n                }\n                left++;\n            }\n            right++;\n        }\n       if(length == INT32_MAX) return \"\";\n       return s.substr(strStart, length);\n    }\n};\n```\n"},{"title":"Hello World","url":"/2024/07/29/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"}]